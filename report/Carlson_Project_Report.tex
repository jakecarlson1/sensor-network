\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{csvsimple}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\geometry{
    letterpaper,
    left=1in,
    right=1in,
    top=1in,
    bottom=1in
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}
\definecolor{gray}{rgb}{0.75, 0.75, 0.75}

\lstdefinestyle{codestyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4
}

\begin{document}

\title{Linear Backbone Determination in a Wireless Sensor Network}
\author{Jake Carlson}
\date{April 10, 2018}
\maketitle

\abstract
A report on implementing algorithms to partition a random geometric graph into bipartite subgraphs. Three different graph geometries are explored: unit square, unit disk, and unit sphere. Nodes are uniformly distributed in the geometry. Then the edges are determined and the verticies are colored using smallest-last vertex ordering and greedy graph coloring. All algorithms used in this report are implemented to run in linear time.
\newpage

\tableofcontents
\lstlistoflistings
\newpage

\section{Executive Summary}

    \subsection{Introduction}
    Random geometric graphs (RGGs) are useful for simulating wireless sensor networks placed in different topologies. This project examines three different geometries: Square, Disk, and Sphere. The user supplies parameters for how many nodes they want in the network and how many connections they want for each node. Then, the simulation finds the average radius needed for that number of connections, finds multiple backbones for the RGG, and displays the results graphically.

    \subsection{Environment Description}
    The data structures and topologies for this simulation are implemented in Python2.7. The graphics are generated using Processing.py \cite{processing}. All development and benchmarking has been done on a 2014 MackBook Pro with a 3 GHz Intel Core i7 processor and 16 GB of DDR3 RAM running macOS High Sierra 10.13.3.
    \par
    Processing offers an easy to use API for drawing and rendering shapes two- and three-dimensions. The Processing.py implementation allows the entire use of the Python programming languages and libraries.
    \par
    A separate data generation script was used to generate the summary tables \ref{tab1}\ref{tab2}. The figures were genetared using the matplotlib library \cite{matplotlib}. This library, and a variety of others, could not be imported into Processing.py because the jython interpreter used by Processing only accepts libraries written in raw Python.
    \par
    The different geometries were implemented in a stand alone Python file and imported into the Processing.py script or the data generation script depending on what was being run. These classes can then be used directly by Processing or the data generation script. Because there is no intermediary file to hold the generated nodes and edges, there is no additional disk space needed to run the simulation. Everything can be done in system memory managed by Processing.

    \begin{center}
        \begin{table}[h]
            \centering
            \csvautotabular{./data/benchmark-data-1.csv}
            \caption{Benchmarks for Generating RGGs. A: input average degree, r: node connection radius}
            \label{tab1}
        \end{table}
    \end{center}

    \begin{center}
        \begin{table}[h]
            \centering
            \csvautotabular{./data/benchmark-data-2.csv}
            \caption{Benchmarks for Coloring RGGs}
            \label{tab2}
        \end{table}
    \end{center}

\section{Reduction to Practice}

    \subsection{Data Structure Design}
    The primary data structure used for this project is an adjacency list. However, to allow for constant time lookup of edges of a node, a Python dictionary is used where the keys are nodes and the values are a list of indicies of adjacent nodes in the original list of nodes. The space needed by the adjacency list is $\Theta(|V| + 2|E|)$. Two entries are used for each edge because they are undirected. This is superior to the adjacency matrix data structure which would require $\Theta(|E|^2)$ space.
    \par
    In order to make this project maintainable as it is developed along the semester, the object-oriented capabilities of Python are used to design the different geometries. First, a Topology class is defined that creates the interface Processing uses to draw the graphs. This base class implements all of the methods needed for node placement and edge detection in 2D graphs. Then, three subclasses are created: Square, Disk, and Sphere.
    \par
    The Square and Disk topologies simply need to override the methods for generating nodes and calculating the node radius needed for the desired average degree. The Sphere subclass needs to override a few additional functions because it exists in a 3D space. Other than the methods for generating nodes and calculating the node radius, it also needs to override the function used to draw the graph so that Processing will render the graph properly in 3D.

    \subsection{Algorithm Descriptions}

        \subsubsection{Node Placement}
        A different node placement algorithm is required for each of the geometries. For the Square, the coordinates for each node are generated as two random numbers taken from a unifrom distribution on the range $[0,1]$. All of these points are guaranteed to be in the unit square.
        \par
        For the Disk, a similar method is used. The coordinates for nodes are randomly sampled from a uniform distribution; however, if a node has a distance from the center of the Disk greater than the radius of 1, the coordinates for that node are resampled.
        \par
        For the Sphere a different method must be used so that all of the nodes are placed on the surface of the Sphere and the volume is vacant. For this geometry, the following equations are used:

        \begin{align}
            x &= \sqrt{1-u^2}\cos\theta \\
            y &= \sqrt{1-u^2}\sin\theta \\
            z &= u
        \end{align}

        where $\theta \in [0,2\pi]$ and $u \in [-1,1]$. This is guaranteed to uniformly distribute nodes on the surface area of the sphere \cite{spherepoints}.
        \par
        All of these algorithms can be solved in $\Theta\left(|V|\right)$ where because each node only needs to be assigned a position once.

        \subsubsection{Edge Determination}
        To calculate the node connection radius needed to acheive the desired average connection, the ratio of node coverage to the total area can be used. This ratio must equal the ratio of the total number of nodes to the average degree, or:

        \begin{align}
            \frac{A_{geometry}}{A_{node}}= \frac{Num\,Nodes}{Avg\,Deg}
        \end{align}

        Applying this to each geometry only requires filling in the equation for the area of the geometry and the connection area. This is straight forward for the square and disk. The geometry areas are given by $R^2 = 1$ and $\pi R^2 = \pi$ respectively since these are the unit square and circle. The sphere is slightly more complicated. Since nodes should only be able to connect over the surface of the sphere (following arcs), the connection area is to be taken as the surface area of the spherical cap such that the arc of the cap is twice the length of the connection distance. In other words, a node placed on the surface of the sphere in the center of a spherical cap can connect to any other node that falls in that spherical cap. The equation for the area of the spherical cap is given by

        \begin{align}
            S_{cap} = \pi (a^2 + h^2)
        \end{align}

        where $a$ is the distance from the midpoint of the base of the cap to the edge of the base, and $h$ is the distance from the midpoint of the base to the top of the cap (where the node would be) \cite{spherecap}. If we connect these points with a third variable, $x$, such that $x$ is the actual distance from the node to the edge of its connection area, the Pythagorean theorem can be used to substitute in $x^2$ for $a^2 + h^2$. The equation for the node connection radius of the unit sphere then looks identical to that of the unit circle. The final list of equations used to calculate node connection radius for a desired average degree are given in Table \ref{tab4}.

        \begin{center}
            \begin{table}[h]
                \centering
                \begin{tabular}{|c|c|c|c|}
                    \hline
                    Geometry & Geometry Area & Node Area & r \\
                    \hline
                    Square & 1 & $\pi r^2$ & $r = \sqrt{\frac{Average\,Deg}{\pi \times Num\,Nodes}}$ \\
                    Disk & $\pi$ & $\pi r^2$ & $r = \sqrt{\frac{Average\,Deg}{Num\,Nodes}}$ \\
                    Sphere & $4\pi$ & $\pi r^2$ & $r = 2 \times \sqrt{\frac{Average\,Deg}{Num\,Nodes}}$ \\
                    \hline
                \end{tabular}

                \caption{Equations for node conneciton radius}
                \label{tab4}
            \end{table}
        \end{center}

        There are several methods for finding the edges in the graph. The brute force method checks every node, and for each node checks all other nodes to see if they are close enough to form an edge. The brute force method is $\Theta\left(|V|^2\right)$.
        \par
        The second method to find the edges is the sweep method. This method first sorts the nodes along the x-axis. Then, for any node, we only need to search left and right until the distance along the x-axis is greater than the connection radius for the nodes. This dramatically reduces the search space. The sweep method is $O\left(n lg(n) + 2rn^2\right)$ where $n = |V|$ an $r$ is the connection radius. The $n lg(n)$ portion is for the sorting and the $2rn^2$ portion is for measuring the distance between nodes in a sweep step.
        \par
        The final method to find edges is the cell method. This method places the nodes into cells of area $r \times r$ based on their position in the topology. When the edge detection runs, each node needs to be visited once, but only the cell the node populates and the neighboring cells need to be searched for connections.
        \par
        The only method that needs to be adjusted for the Sphere is the cell method. Instead of using a two dimensional grid of cells, a three dimentional mesh is needed to divide the topology. The cells then have volume $r \times r \times r$. Only the current cell and the neighboring cells need to be searched.

        \subsubsection{Graph Coloring}
        Two algorithms are used for coloring the graphs. The first is smallest-last vertex ordering, which sorts the verticies based on the number of degrees they have. The second is the greedy graph coloring algorithm.
        \par
        Smallest-last vertex ordering is used to order the nodes for coloring. The steps to this algorithm are as follows \cite{slv}:

        \begin{enumerate}
            \item Initialize a representation of your target graph
            \item Find the vertex $v_j$ of minimum degree in your representation
            \item Update your representation to simulate deleting $v_j$
            \item If there are still verticies in the representation, return to step 1, otherwise terminate with the sequence of verticies removed
        \end{enumerate}

        This algorithm is linear if each of the above steps is linear. Step 1 is linear if we can build a represenation of the graph in linear time. For this, we can use an array of buckets, where each bucket holds the verticies that have the same number of edges as the position of the bucket in the array of buckets. To build this data structure, each node only needs to be visited once, making this linear in both space and time. Next, finding the vertex of minimum degree simply requires finding the lowest index bucket that has a node. This is bounded by the number of buckets, which is bounded by the number of nodes, making Step 2 linear. Next, we have to update the representation of the graph. To do this, we have to look at each node that shares an edge with $v_j$ and move it to the bucket for nodes with one fewer degree. This requires traversing the list of edges for $v_j$ which means Step 3 is linear. Since this is repeated for each node, the runtime of this program is $\Theta\left(|E| + |V|\right)$ and the space needed is $\Theta(|V|)$.
        \par
        After this, a single traversal of the smallest-last vertex ordering is needed to color the graph. As we traverse this list, we check to see if the nodes before it (that are already colored) share an edge with the current node. The node can then be colored with any color it does not share an edge with or, if it shares an edge with all currently used colors, it is assigned a new color. This algorithm is also linear. Each node needs to be visited once and when a node is visited, all previous nodes are checked to see if they are in the edge list of the current node. Because we used smallest last vertex ordering, as we have to check more and more nodes, we get to check fewer and fewer edges. This makes the greedy coloring algorithm $O(|V| + |E|)$.

    \subsection{Algorithm Engineering}

        \subsubsection{Node Placement}
        It is easy to implement the algorithms for placing nodes in the different geometries using Python's math library. This library offers functions for sampling points on a uniform distribution. For the Square, sampling on a range $[0,1]$ is sufficient for all of the nodes. Since each node only needs to be placed once, this runs at $\Theta(|V|)$ where.
        \par
        For the Disk, the node needs to be resampled if it is too far from the center. To do this, the distance function is used to find the distance between the node and the center. If the node is further than $1$ from the center, node generation falls into a while loop which iterates until the node is within the unit circle. Since nodes are taken from a uniform distribution, the number of nodes that will need to be resampled is approximately equal to the ratio of the area of the square that circumscribes the unit circle which falls outside of the unit circle to the total area of the square. This is given by:

        \begin{align}
            \frac{(2r)^2-\pi r^2}{(2r)^2} = \frac{4-\pi}{4} = 0.2146
        \end{align}

        Since the placement algorithm for each node of the Disk will iterate until the node falls within the unit circle, the total number of iterations $N$ can be found as the sum of the geometric series:
        \begin{align}
            N = \sum_{k=0}^{\infty} n (0.2146)^k = \frac{n}{1-0.2146} = 1.273n
        \end{align}
        where $n = |V|$. This shows this implementation is $\Theta\left(n\right)$.
        \par
        For the node placement algorithm of the Sphere, again the math library in Python makes this easy. Each node needs two random values pulled from a uniform distribution, two square root operations, one sine operation, and one cosine operation. Each node only needs to be placed once so the runtime of this algorithm is $\Theta(n)$ where $n = |V|$.

        \subsubsection{Edge Determination}
        Each method implemented for finding edges has a different time complexity. The brute force method uses an outer loop and an inner loop, which each iterate over every node in the graph. An edge is saved to the adjacency list if the nodes are not the same and the distance between them is less than or equal to the calculated node radius. This is guaranteed to run in $\Theta\left(n^2\right)$ where $n = |V|$. The number of times the distance needs to be calculated is $n \times (n-1)$ because it will not be calculated when the nodes are the same (distance would be zero, but no edge is drawn here). No additional space is needed for the brute force method so the space complexity is $O(1)$.
        \par
        The implementation of sweep starts by sorting the nodes along the x-axis. Python lists have a built-in sort function that has $O\left(n lg(n)\right)$ time complexity \cite{listsort}. After this stage, it iterates over every node building a search space which will be scaned for edges. For each node, the list of nodes is searched right $~r\times n$ nodes to find those within one radius length of the current node. With the search space built, the search space is iterated over once to find nodes that have a distance less than or equal the node radius. Then, the indicies of the nodes are added to the adjacency list entry for each other. My implementation of this runs in $O\left(n lg(n) + 2rn\right)$ where $n = |V|$ and $r$ is the node connection radius. Because the list sort method sorts inplace, the only additional space needed is for the search space. This saves $O(rn)$ nodes and is reset after every iteration.
        \par
        The cell method implementation works in linear time. In the first step of the method, the cells are initialized as a list of empty lists. There are $(1/r + 1)^2$ cells. The nodes are then iterated over and assigned a cell by dividing their x and y coordinates by the node radius. At this point, the cells are iterated over and, for each node in the cell, the nodes in the current cell and the four forward adjacent cells and the are checked to see if they fall within the node radius of the current node. All together, this implementation runs at $O\left(n + n + 5nr^2\right) = O\left((2 + 5r^2)n\right)$ where $n = |V|$. The amount of additional space needed is equal to the number of nodes because they are coppied into their respective cells. This places the space complexity at $\Theta(n)$.

        \subsubsection{Graph Coloring}
        Implementing the smallest-last coloring algorithm involves implementing the smallest-last vertex ordering algorithm and the greedy graph coloring algorithm. For smallest-last vertex ordering, the first thing to do is build the data structure used to represent the graph with deleted nodes. This can be done with a list of sets, where each the index in the list represents the degree of the nodes in that set. The number of sets needed is equal to the maximum degree of the nodes. The index of each node is placed in the set corresponding to the number of edges it has then the RGG. Simultaneously, a dictionary is created that maps each node to the number of degrees it has in the graph with deletions. Each value starts at the number of edges the corresponding node has in the RGG. At this point, we have iterated over all of the nodes once and allocated space for twice the number of nodes by copying them into the sets and using them as the keys for the degrees dictionary.
        \par
        Because Python dictionaries resize at specific numbers of entries, we can determine the number of additional insertions caused by rehashing while the degrees dictionary is built. Python dictionaries start out with space for 8 entries and quadruple in size until the number of entries is above 50,000, at which point it begins to double in size. Clearly the dictionary grows at a logarithmic rate, but the total number of insertions $I$ for an input size of $n$ is given by:

        \begin{align}
            I =
            \begin{cases}
                n + 8\sum_{k=1}^{\log_4\lceil n/8\rceil}4^k & n \leq 50,000 \\
                n + 8\sum_{k=1}^{6}4^k + 32768\sum_{k=1}^{\log_2\lceil n/32768\rceil}2^k & n > 50,000
            \end{cases}
        \end{align}

        Fortunately, because the entire dictionary is built before it is used by the smallest-last vertex ordering algorithm, it will never again be resized once the algorithm starts. Unfortunately, the sets resize at a similar rate and it is more difficult to predict how large the sets will need to be when performing smallest-last vertex ordering. The degree dictionary will also be used to index into the sets, so we gain a speed up here by not having to iterate over all of the edges for a node and determining if the node it shares an edge with are in the remaining graph each time we want to sift nodes down to lower set.
        \par
        After setting up the graph representation, the smallest-last vertex ordering algorithm runs until every node has been removed from the representation. To delete a node, the first non-empty set is selected. This set must contain the next node to remove becuase it contains all nodes with smallest degree. Before deleting the node from the graph, and moving all adjacent nodes down a set, the current set is checked to see if it has all remaining nodes. If this is the case, the terminal clique has been found, and the size of the terminal clique must be saved. After this check, a node is popped from the end of the current set, and appended to the smallest-last ordering result. Then, all nodes adjacent to the popped node in the original graph are checked to see if they are in the set with its current degree. If it is, the number of degrees for that node can be decremented and the node can be placed into the correct set for its new degree.
        \par
        The last step is to reverse the order of the smallest-last ordering result because it was built in the opposite order (smallest-first). All together, excluding the initialization of accessory data structures, this implementation runs in $\Theta(2|V| + 2|E|)$ time and $\Theta(2|V|)$ space since nodes are removed from the buckets and added to the result.
        \par
        After this the graph needs to be colored. For this, initially each node is assigned a color of $-1$ in a node color array that is parallel to the original list of nodes. Then, all of the nodes in the smallest-last vertex ordering are iterated over. At each node, a set of colors that is already used by the neighbors of that node is created by iterating over all of its edge nodes and grabbing their color from the node color array. Then, color just has to be incremented from $0$ until it does not exist in the search space set and the color has been determined to assign to the node.
        \par
        Since the smallest-last odering is used, each time the edges need to be traversed to see if a node is adjacent to the current node, nodes with fewer and fewer edges are being searched. This means that the nodes with the most neighbors are searched first, when the number of other nodes to check is lowest, and the nodes with the fewest neighbors are searched last, when we have the most nodes to check if they share an edge with the current node. All together, this implementation runs in $\Theta(|V| + 2|E|)$ time and $\Theta(|V|)$ space because we need a new array for the colors assigned to each of the nodes.
        \par
        A setp-by-step walkthough of the smallest-last coloring algorithm is provided to further visualize this algorithm. For this walkthrough, a unit square topology is used with 20 nodes and a node connection radius of 0.4. The smallest-last vertex ordering deletion process is shown in Figure \ref{slvodel}. The coloring phase is shown in Figure \ref{slvocolor}. In the deletion process, the minimum degree node is removed at each step. If there are multiple nodes with the same minimum degree, one is choosen randomly. Once all nodes have been removed, the smallest-last vertex ordering has been detemrined. In the coloring phase, the node that was removed last is assigned a color first. As the smallest-last vertex ordering is traversed, each node's neighbors are checked to see if they have been assigned a color. The first color that has not been used by a neighbor is assigned to the node. To complete this walkthrough, the distribution of the color set sizes and the degrees of nodes when deleted is given in Figure \ref{histwt}.

        \begin{figure}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-0.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-1.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-2.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-3.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-4.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-5.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-6.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-7.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-8.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-9.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-10.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-11.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-12.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-13.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-14.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-15.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-16.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-17.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-18.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/slvo-19.png}}
            \end{minipage}

            \caption{Smallest-last vertex ordering deletion process}
            \label{slvodel}
        \end{figure}

        \begin{figure}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-1.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-2.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-3.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-4.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-5.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-6.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-7.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-8.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-9.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-10.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-11.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-12.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-13.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-14.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-15.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-16.png}}
            \end{minipage}
            \vskip 0.1in
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-17.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-18.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-19.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.2\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./images/color-20.png}}
            \end{minipage}

            \caption{Smallest-last vertex ordering coloring process}
            \label{slvocolor}
        \end{figure}

        \begin{figure}
            \begin{minipage}{0.45\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_wt.png}}
            \end{minipage}
            \hspace{\fill}
            \begin{minipage}{0.45\textwidth}
            \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_wt.png}}
            \end{minipage}

            \caption{Distribution of degree when deleted and color set size for the 20 node walkthrough}
            \label{histwt}
        \end{figure}

    \subsection{Verification}

        \subsubsection{Node Placement}
        The nodes can be verified to be distributed uniformly if the degrees follow a normal distribution. To show that the distribution of degrees for each of the geometries are following a normal distribution, the degree histograms are plotted for each of the benchmarks. The histrograms for Square are given in Figure \ref{squaredeghists}, Disk are given in Figure \ref{diskdeghists}, and Sphere are given in Figure \ref{spheredeghists}. These histograms clearly follow a normal distribution, so the nodes must be placed uniformly.

        \subsubsection{Edge Determination}
        The runtime for the edge detection methods can be verified by varying the number of nodes and measuring the runtime of each algorithm. By looking at how the runtime grows, we can calculate the trendline that best fits the growth rate. For the first comparison, the number of nodes is varied from 4,000 to 64,000 in steps of 4,000, while holding the desired average dgree constant at 16. As we can see in Figure \ref{avgdeg}, the growth rates of the brute force and sweep methods are quadratic, while the growth rate of the cell method. The trendline functions are given on the graph.
        \par
        For the second metric, the number of nodes is held constant at 32,000 and varied the desired average degree from 2 to 32 in steps of 2. The graph is given in Figure \ref{avgdeg}. The cell method clearly grows linearly, but the sweep method is harder to gauge. Since varying the desired average degree should only change the node radius, this should grow linearly as well. However, because each graph is randomly generated, some graphs can have nodes that are closer to sorted order than others. This can effect the measured runtime.

        \subsubsection{Graph Coloring}
        Smallest-last vertex ordering can be verified by looking at the distribution of the degrees of nodes when deleted. Since this algorithm repeatedly removes the node with the fewest connections, and because the removal of that node will cause the fewest number of nodes to move to the next lowest bucket, we would expect the bulk of the nodes to have a large degree when they are deleted. This would be indicated by a negative skew in the distribution of degrees when deleted. Additionally, since the nodes are only removed when they satisfy the criteria of being the node with the minimum degree, we should see the standard deviation of the distribution of nodes to be much smaller than in the original distribution of degrees. Both of these features can be found in Figures \ref{squaredegdelhists}, \ref{diskdegdelhists}, and \ref{spheredegdelhists} which plot the original distribution of degrees alongside the distribution of degrees when deleted. We see that the distribution of degrees when deleted follows a normal distrbution with a negative skew and a relatively small standard deviation compared to the original distribution of degrees.
        \par
        The color sets can be verified by looking at the distribution of colors used to color the graph. The number of items in each color should follow a trend where the first colors used have the most members, and the last colors have the fewest items because they are used to accommodate nodes where the earlier colors are all used by a node's neighbors. This trend is shown in Figures \ref{squarecolorhists}, \ref{diskcolorhists}, and \ref{spherecolorshists}.
        \par
        To further verify the accuracy of the smallest-last coloring implementation additional code was used to verify that the coloring result was correct while running benchmarks. All of the nodes in the smallest-last vertex ordering are traversed, and for each node, the edges are visited to see if any adjacent nodes have the same color as the node being checked. If any of these neighbors have the same color, the coloring is not correct and our independent sets cannot be used for backbone determination. All of the benchmarks ran and returned valid colorings.

% \section{Results Summary}

\newpage

\begin{thebibliography}{10}
    \bibitem{slv}
    Matula, David; Beck, Leland, Smallest-Last Ordering and Clustering and Graph Coloring Algorithms, 1983

    \bibitem{ian}
    Johnson, Ian, Linear-Time Computation of High-Converage Backbones for Wireless Sensor Networks, https://github.com/ianjjohnson/SensorNetwork/blob/master/Report/Report.pdf, 2016

    \bibitem{processing}
    Fry, Ben; Reas Casey, Processing, https://processing.org, 2018 v3.3.7

    \bibitem{matplotlib}
    The Matplotlib Development, matplotlib, https://matplotlib.org, 2018

    \bibitem{spherepoints}
    Weisstein, Eric W., Wolfram MathWorld Sphere Point Picking, http://mathworld.wolfram.com/SpherePointPicking.html

    \bibitem{spherecap}
    Weisstein, Eric W., Wolfram MathWorld Spherical Cap, http://mathworld.wolfram.com/SphericalCap.html

    \bibitem{listsort}
    Peters, Tim, Timsort, http://svn.python.org/projects/python/trunk/Objects/listsort.txt

    \bibitem{dictresize}
    Rees, Gareth, Python's underlying hash data structure for dictionaries, https://stackoverflow.com/questions/4279358/pythons-underlying-hash-data-structure-for-dictionaries, 2010

    \bibitem{tupletiming}
    Thomas, Alec, Why is tuple faster than list?, https://stackoverflow.com/questions/3340539/why-is-tuple-faster-than-list, 2010

    \bibitem{fortiming}
    Kruse, Lars, Python Speed, Performance Tips, https://wiki.python.org/moin/PythonSpeed/PerformanceTips, 2016

\end{thebibliography}

\newpage

\section{Appendix A - Figures}

\begin{figure}[h]
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/run_time_avg_deg_16.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/run_time_var_avg_deg.png}}
    \end{minipage}

    \caption{Runtime for edge detection methods. left: constant average degree of 16, right: variable average degree}
    \label{avgdeg}
\end{figure}

\begin{figure}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_square_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_square_1.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_square_2.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_square_3.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_square_4.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_square_5.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_square_6.png}}
    \end{minipage}
    \hspace{\fill}

    \caption{Square benchmarks distribution of degree graphs}
    \label{squaredeghists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_disk_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_disk_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_disk_2.png}}
    \end{minipage}

    \caption{Disk benchmarks distribution of degree graphs}
    \label{diskdeghists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_sphere_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_sphere_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_sphere_2.png}}
    \end{minipage}

    \caption{Sphere benchmarks distribution of degree graphs}
    \label{spheredeghists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_square_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_square_1.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_square_2.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_square_3.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_square_4.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_square_5.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_square_6.png}}
    \end{minipage}
    \hspace{\fill}

    \caption{Square benchmarks distribution of degree when deleted graphs}
    \label{squaredegdelhists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_disk_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_disk_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_disk_2.png}}
    \end{minipage}

    \caption{Disk benchmarks distribution of degree when deleted graphs}
    \label{diskdegdelhists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_sphere_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_sphere_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_deg_del_sphere_2.png}}
    \end{minipage}

    \caption{Sphere benchmarks distribution of degree when deleted graphs}
    \label{spheredegdelhists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_square_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_square_1.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_square_2.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_square_3.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_square_4.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_square_5.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_square_6.png}}
    \end{minipage}
    \hspace{\fill}

    \caption{Square benchmarks distribution of colors graphs}
    \label{squarecolorhists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_disk_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_disk_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_disk_2.png}}
    \end{minipage}

    \caption{Disk benchmarks distribution of colors graphs}
    \label{diskcolorhists}
\end{figure}

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_sphere_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_sphere_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./graphs/hist_colors_sphere_2.png}}
    \end{minipage}

    \caption{Sphere benchmarks distribution of colors graphs}
    \label{spherecolorshists}
\end{figure}

% square images

\begin{figure}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/square_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/square_1.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/square_2.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/square_3.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/square_4.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/square_5.png}}
    \end{minipage}
    \vskip 0.1in
    \begin{minipage}{0.3\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/square_6.png}}
    \end{minipage}
    \hspace{\fill}

    \caption{Square benchmark graphs}
    \label{squares}
\end{figure}

% disk images

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/disk_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/disk_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/disk_2.png}}
    \end{minipage}

    \caption{Disk benchmark graphs}
    \label{disks}
\end{figure}

% sphere images

\begin{figure}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/sphere_0.png}}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/sphere_1.png}}
    \end{minipage}
    \vskip 0.25in
    \begin{minipage}{0.45\textwidth}
    \colorbox{gray}{\includegraphics[width=\linewidth]{./images/sphere_2.png}}
    \end{minipage}

    \caption{Sphere benchmark graphs}
    \label{spheres}
\end{figure}

\newpage

\section{Appendix B - Code Listings}

\lstset{style=codestyle}

\lstinputlisting[language=Python, caption=Processing driver]{../Processing/Processing.pyde}

\lstinputlisting[language=Python, caption=Topology class and subclasses]{../Processing/objects/topology.py}

\end{document}
